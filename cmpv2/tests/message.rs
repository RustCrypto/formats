use cmpv2::body::PkiBody;
use cmpv2::header::{PkiHeader, Pvno};
use cmpv2::message::PkiMessage;
use cmpv2::response::{CertRepMessage, CertResponse, CertResponses};
use der::{Decode, Encode};
use hex_literal::hex;

// commented out code that uses manually instantiated openssl mock CMP server
// async fn post_cert_req(uri: &str, enc_req: &[u8]) -> Result<Vec<u8>, String> {
//     use core::time::Duration;
//     let client = if let Ok(client) = reqwest::Client::builder()
//         .pool_max_idle_per_host(0)
//         .timeout(Duration::from_secs(10))
//         .build()
//     {
//         client
//     } else {
//         return Err(format!("Failed to prepare client: {}", uri));
//     };
//
//     let body = match client
//         .post(uri)
//         .body(enc_req.to_vec())
//         .header(reqwest::header::CONTENT_TYPE, "application/pkixcmp")
//         .send()
//         .await
//     {
//         Ok(b) => b,
//         Err(e) => {
//             return Err(format!("CMPv2 request send failed with {}: {}", e, uri));
//         }
//     };
//
//     let body_bytes = match body.bytes().await {
//         Ok(bb) => bb,
//         Err(e) => {
//             return Err(format!("Failed to read CMPv2 response with {}: {}", e, uri));
//         }
//     };
//
//     Ok(body_bytes.to_vec())
// }
//
// // This test uses a canned request generated by OpenSSL that is presented to an openssl mock server,
// // which returns a response containing examples/ec384-ee-key.crt, which features the same public key
// // as the request. The mock server is started using files present in the examples folder as follows:
// // openssl cmp -port 8080 -srv_ref ABCD --srv_key ec384-server-key.pem -srv_cert ec384-server-key.crt -rsp_cert ec384-ee-key.crt
// #[tokio::test]
// async fn client_test() {
//     use cmpv2::certified_key_pair::CertOrEncCert;
//     let req_01 = include_bytes!("examples/req_01.bin");
//     let result = PkiMessage::from_der(req_01);
//     println!("{:?}", result);
//     assert!(result.is_ok());
//     let pki_message_req = result.unwrap();
//
//     let reencoded_req_01 = pki_message_req.to_vec().unwrap();
//     println!("Original : {:02X?}", req_01);
//     println!("Reencoded: {:02X?}", reencoded_req_01);
//     assert_eq!(req_01, reencoded_req_01.as_slice());
//
//     let result = post_cert_req("http://127.0.0.1:8080", reencoded_req_01.as_slice()).await;
//     assert!(result.is_ok());
//     let enc_resp = result.unwrap();
//     println!("Response length: {:?}", enc_resp.len());
//     println!("Response : {:02X?}", enc_resp);
//
//     let result = PkiMessage::from_der(enc_resp.as_slice());
//     println!("{:?}", result);
//     assert!(result.is_ok());
//     let pki_message_rsp = result.unwrap();
//     let ir = match pki_message_req.body {
//         PkiBody::Ir(ir) => ir,
//         _ => panic!()
//     };
//     let ip = match pki_message_rsp.body {
//         PkiBody::Ip(ip) => ip,
//         _ => panic!()
//     };
//
//     let cert_response = &ip.response[0];
//     let certified_key_pair = cert_response.certified_key_pair.as_ref().unwrap();
//     let cert = match &certified_key_pair.cert_or_enc_cert {
//         CertOrEncCert::Certificate(c) => c,
//         _ => panic!()
//     };
//
//     let cert_req = &ir[0];
//     let spki = cert_req.cert_req.cert_template.subject_public_key_info.as_ref().unwrap();
//     assert_eq!(*spki, cert.tbs_certificate.subject_public_key_info);
// }

#[test]
fn req_header_test() {
    // read PkiHeader cracked from request object used in req_message_test
    let header_01 = include_bytes!("examples/req_header_01.bin");
    let result = PkiHeader::from_der(header_01);
    assert!(result.is_ok());
    let header = result.unwrap();
    assert_eq!(header.pvno, Pvno::Cmp2000);

    let reencoded_header_01 = header.to_vec().unwrap();
    println!("Original : {:02X?}", header_01);
    println!("Reencoded: {:02X?}", reencoded_header_01);
    assert_eq!(header_01, reencoded_header_01.as_slice());
}

#[test]
fn req_body_test() {
    // read PkiBody cracked from request object used in req_message_test
    let body_01 = include_bytes!("examples/req_body_01.bin");
    let result = PkiBody::from_der(body_01);
    println!("{:?}", result);
    assert!(result.is_ok());
    let body = result.unwrap();

    let reencoded_body_01 = body.to_vec().unwrap();
    println!("Original : {:02X?}", body_01);
    println!("Reencoded: {:02X?}", reencoded_body_01);
    assert_eq!(body_01, reencoded_body_01.as_slice());
}

#[test]
fn req_message_test() {
    // read request object created and captured via:
    // server:
    //   - openssl ecparam -genkey -name secp384r1 -noout -out ec384-server-key.pem
    //   - openssl req -new -key ec384-server-key.pem -out ec384-server-key.csr
    //   - openssl req -text -in ec384-server-key.csr -noout
    //   - openssl x509 -req -days 365 -in ec384-server-key.csr -signkey ec384-server-key.pem -out ec384-server-key.crt
    //   - openssl cmp -port 8888 -srv_ref ABCD --srv_key ec384-server-key.pem -srv_cert ec384-server-key.crt
    // client:
    //   - openssl ecparam -genkey -name secp384r1 -noout -out ec384-key-pair.pem
    //   - openssl cmp -cmd ir -server 127.0.0.1:8888 -path pkix/ -ref 1234 -secret pass:1234-5678-1234-5678 -recipient "/CN=CMPserver" -newkey ec384-key-pair.pem -subject "/CN=MyName" -cacertsout capubs.pem -certout cl_cert.pem -srv_cert ec384-server-key.crt -reqout req.bin -rspout rsp.bin
    let req_01 = include_bytes!("examples/req_01.bin");
    let result = PkiMessage::from_der(req_01);
    println!("{:?}", result);
    assert!(result.is_ok());
    let message = result.unwrap();

    let reencoded_req_01 = message.to_vec().unwrap();
    println!("Original : {:02X?}", req_01);
    println!("Reencoded: {:02X?}", reencoded_req_01);
    assert_eq!(req_01, reencoded_req_01.as_slice());
}

#[test]
fn rsp_header_test() {
    // read PkiHeader cracked from request object used in rsp_message_test
    let header_01 = include_bytes!("examples/rsp_header_01.bin");
    let result = PkiHeader::from_der(header_01);
    assert!(result.is_ok());
    let header = result.unwrap();
    assert_eq!(header.pvno, Pvno::Cmp2000);

    let reencoded_header_01 = header.to_vec().unwrap();
    println!("Original : {:02X?}", header_01);
    println!("Reencoded: {:02X?}", reencoded_header_01);
    assert_eq!(header_01, reencoded_header_01.as_slice());
}

#[test]
fn rsp_body_test() {
    // read PkiBody cracked from request object used in rsp_message_test
    let body_01 = &hex!("A10E300C300A30080201003003020100");
    let result = PkiBody::from_der(body_01);
    println!("{:?}", result);
    assert!(result.is_ok());
    let body = result.unwrap();

    let reencoded_body_01 = body.to_vec().unwrap();
    println!("Original : {:02X?}", body_01);
    println!("Reencoded: {:02X?}", reencoded_body_01);
    assert_eq!(body_01, reencoded_body_01.as_slice());
}

#[test]
fn certrepmessage_test() {
    // read CertRepMessage cracked from request object used in rsp_message_test
    let orig_cert_response = &hex!("300C300A30080201003003020100");
    let result = CertRepMessage::from_der(orig_cert_response);
    println!("{:?}", result);
    assert!(result.is_ok());
    let cert_response = result.unwrap();

    let reencoded_cert_response = cert_response.to_vec().unwrap();
    println!("Original : {:02X?}", orig_cert_response);
    println!("Reencoded: {:02X?}", reencoded_cert_response);
    assert_eq!(orig_cert_response, reencoded_cert_response.as_slice());
}

#[test]
fn cert_responses_test() {
    // read CertResponses cracked from request object used in rsp_message_test
    let orig_cert_responses = &hex!("300A30080201003003020100");
    let result = CertResponses::from_der(orig_cert_responses);
    println!("{:?}", result);
    assert!(result.is_ok());
    let cert_response = result.unwrap();

    let reencoded_cert_response = cert_response.to_vec().unwrap();
    println!("Original : {:02X?}", orig_cert_responses);
    println!("Reencoded: {:02X?}", reencoded_cert_response);
    assert_eq!(orig_cert_responses, reencoded_cert_response.as_slice());
}

#[test]
fn cert_response_test() {
    // read CertResponse cracked from request object used in rsp_message_test
    let orig_cert_response = &hex!("30080201003003020100");
    let result = CertResponse::from_der(orig_cert_response);
    println!("{:?}", result);
    assert!(result.is_ok());
    let cert_response = result.unwrap();

    let reencoded_cert_response = cert_response.to_vec().unwrap();
    println!("Original : {:02X?}", orig_cert_response);
    println!("Reencoded: {:02X?}", reencoded_cert_response);
    assert_eq!(orig_cert_response, reencoded_cert_response.as_slice());
}

#[test]
fn rsp_message_test() {
    // read request object created and captured via:
    // server:
    //   - openssl ecparam -genkey -name secp384r1 -noout -out ec384-server-key.pem
    //   - openssl req -new -key ec384-server-key.pem -out ec384-server-key.csr
    //   - openssl req -text -in ec384-server-key.csr -noout
    //   - openssl x509 -req -days 365 -in ec384-server-key.csr -signkey ec384-server-key.pem -out ec384-server-key.crt
    //   - openssl cmp -port 8888 -srv_ref ABCD --srv_key ec384-server-key.pem -srv_cert ec384-server-key.crt
    // client:
    //   - openssl ecparam -genkey -name secp384r1 -noout -out ec384-key-pair.pem
    //   - openssl cmp -cmd ir -server 127.0.0.1:8888 -path pkix/ -ref 1234 -secret pass:1234-5678-1234-5678 -recipient "/CN=CMPserver" -newkey ec384-key-pair.pem -subject "/CN=MyName" -cacertsout capubs.pem -certout cl_cert.pem -srv_cert ec384-server-key.crt -reqout req.bin -rspout rsp.bin
    let req_01 = include_bytes!("examples/rsp_01.bin");
    let result = PkiMessage::from_der(req_01);
    println!("{:?}", result);
    assert!(result.is_ok());
    let message = result.unwrap();

    let reencoded_req_01 = message.to_vec().unwrap();
    println!("Original : {:02X?}", req_01);
    println!("Reencoded: {:02X?}", reencoded_req_01);
    assert_eq!(req_01, reencoded_req_01.as_slice());
}
