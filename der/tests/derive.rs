//! Tests for custom derive support.
//!
//! # Debugging with `cargo expand`
//!
//! To expand the Rust code generated by the proc macro when debugging
//! issues related to these tests, run:
//!
//! $ cargo expand --test derive --all-features

#![cfg(all(feature = "derive", feature = "alloc"))]
// TODO: fix needless_question_mark in the derive crate
#![allow(clippy::bool_assert_comparison, clippy::needless_question_mark)]

#[derive(Debug)]
#[allow(dead_code)]
pub struct CustomError(der::Error);

impl From<der::Error> for CustomError {
    fn from(value: der::Error) -> Self {
        Self(value)
    }
}

impl From<std::convert::Infallible> for CustomError {
    fn from(_value: std::convert::Infallible) -> Self {
        unreachable!()
    }
}

/// Custom derive test cases for the `Choice` macro.
mod choice {
    use super::CustomError;

    /// `Choice` with `EXPLICIT` tagging.
    mod explicit {
        use super::CustomError;
        use der::{
            asn1::{GeneralizedTime, UtcTime},
            Choice, Decode, Encode, SliceWriter,
        };
        use hex_literal::hex;
        use std::time::Duration;

        /// Custom derive test case for the `Choice` macro.
        ///
        /// Based on `Time` as defined in RFC 5280:
        /// <https://tools.ietf.org/html/rfc5280#page-117>
        ///
        /// ```text
        /// Time ::= CHOICE {
        ///      utcTime        UTCTime,
        ///      generalTime    GeneralizedTime }
        /// ```
        #[derive(Choice)]
        pub enum Time {
            #[asn1(type = "UTCTime")]
            UtcTime(UtcTime),

            #[asn1(type = "GeneralizedTime")]
            GeneralTime(GeneralizedTime),
        }

        impl Time {
            fn to_unix_duration(&self) -> Duration {
                match self {
                    Time::UtcTime(t) => t.to_unix_duration(),
                    Time::GeneralTime(t) => t.to_unix_duration(),
                }
            }
        }

        #[derive(Choice)]
        #[asn1(error = CustomError)]
        pub enum WithCustomError {
            #[asn1(type = "GeneralizedTime")]
            Foo(GeneralizedTime),
        }

        const UTC_TIMESTAMP_DER: &[u8] = &hex!("17 0d 39 31 30 35 30 36 32 33 34 35 34 30 5a");
        const GENERAL_TIMESTAMP_DER: &[u8] =
            &hex!("18 0f 31 39 39 31 30 35 30 36 32 33 34 35 34 30 5a");

        #[test]
        fn decode() {
            let utc_time = Time::from_der(UTC_TIMESTAMP_DER).unwrap();
            assert_eq!(utc_time.to_unix_duration().as_secs(), 673573540);

            let general_time = Time::from_der(GENERAL_TIMESTAMP_DER).unwrap();
            assert_eq!(general_time.to_unix_duration().as_secs(), 673573540);

            let WithCustomError::Foo(with_custom_error) =
                WithCustomError::from_der(GENERAL_TIMESTAMP_DER).unwrap();
            assert_eq!(with_custom_error.to_unix_duration().as_secs(), 673573540);
        }

        #[test]
        fn encode() {
            let mut buf = [0u8; 128];

            let utc_time = Time::from_der(UTC_TIMESTAMP_DER).unwrap();
            let mut encoder = SliceWriter::new(&mut buf);
            utc_time.encode(&mut encoder).unwrap();
            assert_eq!(UTC_TIMESTAMP_DER, encoder.finish().unwrap());

            let general_time = Time::from_der(GENERAL_TIMESTAMP_DER).unwrap();
            let mut encoder = SliceWriter::new(&mut buf);
            general_time.encode(&mut encoder).unwrap();
            assert_eq!(GENERAL_TIMESTAMP_DER, encoder.finish().unwrap());
        }
    }

    /// `Choice` with `IMPLICIT` tagging.
    mod implicit {
        use der::{
            asn1::{BitStringRef, GeneralizedTime},
            Choice, Decode, Encode, SliceWriter,
        };
        use hex_literal::hex;

        /// `Choice` macro test case for `IMPLICIT` tagging.
        #[derive(Choice, Debug, Eq, PartialEq)]
        #[asn1(tag_mode = "IMPLICIT")]
        pub enum ImplicitChoice<'a> {
            #[asn1(context_specific = "0", type = "BIT STRING")]
            BitString(BitStringRef<'a>),

            #[asn1(context_specific = "1", type = "GeneralizedTime")]
            Time(GeneralizedTime),

            #[asn1(context_specific = "2", type = "UTF8String")]
            Utf8String(String),
        }

        impl<'a> ImplicitChoice<'a> {
            pub fn bit_string(&self) -> Option<BitStringRef<'a>> {
                match self {
                    Self::BitString(bs) => Some(*bs),
                    _ => None,
                }
            }

            pub fn time(&self) -> Option<GeneralizedTime> {
                match self {
                    Self::Time(time) => Some(*time),
                    _ => None,
                }
            }
        }

        const BITSTRING_DER: &[u8] = &hex!("80 04 00 01 02 03");
        const TIME_DER: &[u8] = &hex!("81 0f 31 39 39 31 30 35 30 36 32 33 34 35 34 30 5a");

        #[test]
        fn decode() {
            let cs_bit_string = ImplicitChoice::from_der(BITSTRING_DER).unwrap();
            assert_eq!(
                cs_bit_string.bit_string().unwrap().as_bytes().unwrap(),
                &[1, 2, 3]
            );

            let cs_time = ImplicitChoice::from_der(TIME_DER).unwrap();
            assert_eq!(
                cs_time.time().unwrap().to_unix_duration().as_secs(),
                673573540
            );
        }

        #[test]
        fn encode() {
            let mut buf = [0u8; 128];

            let cs_bit_string = ImplicitChoice::from_der(BITSTRING_DER).unwrap();
            let mut encoder = SliceWriter::new(&mut buf);
            cs_bit_string.encode(&mut encoder).unwrap();
            assert_eq!(BITSTRING_DER, encoder.finish().unwrap());

            let cs_time = ImplicitChoice::from_der(TIME_DER).unwrap();
            let mut encoder = SliceWriter::new(&mut buf);
            cs_time.encode(&mut encoder).unwrap();
            assert_eq!(TIME_DER, encoder.finish().unwrap());
        }
    }
}

/// Custom derive test cases for the `Enumerated` macro.
mod enumerated {
    use super::CustomError;
    use der::{Decode, Encode, Enumerated, SliceWriter};
    use hex_literal::hex;

    /// X.509 `CRLReason`.
    #[derive(Enumerated, Copy, Clone, Debug, Eq, PartialEq)]
    #[repr(u32)]
    pub enum CrlReason {
        Unspecified = 0,
        KeyCompromise = 1,
        CaCompromise = 2,
        AffiliationChanged = 3,
        Superseded = 4,
        CessationOfOperation = 5,
        CertificateHold = 6,
        RemoveFromCrl = 8,
        PrivilegeWithdrawn = 9,
        AaCompromised = 10,
    }

    const UNSPECIFIED_DER: &[u8] = &hex!("0a 01 00");
    const KEY_COMPROMISE_DER: &[u8] = &hex!("0a 01 01");

    #[derive(Enumerated, Copy, Clone, Eq, PartialEq, Debug)]
    #[asn1(error = CustomError)]
    #[repr(u32)]
    pub enum EnumWithCustomError {
        Unspecified = 0,
        Specified = 1,
    }

    #[test]
    fn decode() {
        let unspecified = CrlReason::from_der(UNSPECIFIED_DER).unwrap();
        assert_eq!(CrlReason::Unspecified, unspecified);

        let key_compromise = CrlReason::from_der(KEY_COMPROMISE_DER).unwrap();
        assert_eq!(CrlReason::KeyCompromise, key_compromise);

        let custom_error_enum = EnumWithCustomError::from_der(UNSPECIFIED_DER).unwrap();
        assert_eq!(custom_error_enum, EnumWithCustomError::Unspecified);
    }

    #[test]
    fn encode() {
        let mut buf = [0u8; 128];

        let mut encoder = SliceWriter::new(&mut buf);
        CrlReason::Unspecified.encode(&mut encoder).unwrap();
        assert_eq!(UNSPECIFIED_DER, encoder.finish().unwrap());

        let mut encoder = SliceWriter::new(&mut buf);
        CrlReason::KeyCompromise.encode(&mut encoder).unwrap();
        assert_eq!(KEY_COMPROMISE_DER, encoder.finish().unwrap());
    }
}

/// Custom derive test cases for the `Sequence` macro.
#[cfg(feature = "oid")]
mod sequence {
    use super::CustomError;
    use core::marker::PhantomData;
    use der::{
        asn1::{AnyRef, ObjectIdentifier, SetOf},
        Decode, Encode, Sequence, ValueOrd,
    };
    use hex_literal::hex;

    pub fn default_false_example() -> bool {
        false
    }

    // Issuing distribution point extension as defined in [RFC 5280 Section 5.2.5] and as identified by the [`PKIX_PE_SUBJECTINFOACCESS`](constant.PKIX_PE_SUBJECTINFOACCESS.html) OID.
    //
    // ```text
    // IssuingDistributionPoint ::= SEQUENCE {
    //      distributionPoint          [0] DistributionPointName OPTIONAL,
    //      onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE,
    //      onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE,
    //      onlySomeReasons            [3] ReasonFlags OPTIONAL,
    //      indirectCRL                [4] BOOLEAN DEFAULT FALSE,
    //      onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
    //      -- at most one of onlyContainsUserCerts, onlyContainsCACerts,
    //      -- and onlyContainsAttributeCerts may be set to TRUE.
    // ```
    //
    // [RFC 5280 Section 5.2.5]: https://datatracker.ietf.org/doc/html/rfc5280#section-5.2.5
    #[derive(Sequence)]
    pub struct IssuingDistributionPointExample {
        // Omit distributionPoint and only_some_reasons because corresponding structs are not
        // available here and are not germane to the example
        // distributionPoint          [0] DistributionPointName OPTIONAL,
        //#[asn1(context_specific="0", optional="true", tag_mode="IMPLICIT")]
        //pub distribution_point: Option<DistributionPointName<'a>>,
        /// onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE,
        #[asn1(
            context_specific = "1",
            default = "default_false_example",
            tag_mode = "IMPLICIT"
        )]
        pub only_contains_user_certs: bool,

        /// onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE,
        #[asn1(
            context_specific = "2",
            default = "default_false_example",
            tag_mode = "IMPLICIT"
        )]
        pub only_contains_cacerts: bool,

        // onlySomeReasons            [3] ReasonFlags OPTIONAL,
        //#[asn1(context_specific="3", optional="true", tag_mode="IMPLICIT")]
        //pub only_some_reasons: Option<ReasonFlags<'a>>,
        /// indirectCRL                [4] BOOLEAN DEFAULT FALSE,
        #[asn1(
            context_specific = "4",
            default = "default_false_example",
            tag_mode = "IMPLICIT"
        )]
        pub indirect_crl: bool,

        /// onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE
        #[asn1(
            context_specific = "5",
            default = "default_false_example",
            tag_mode = "IMPLICIT"
        )]
        pub only_contains_attribute_certs: bool,

        /// Test handling of PhantomData.
        pub phantom: PhantomData<()>,
    }

    // Extension as defined in [RFC 5280 Section 4.1.2.9].
    //
    // The ASN.1 definition for Extension objects is below. The extnValue type may be further parsed using a decoder corresponding to the extnID value.
    //
    // ```text
    //    Extension  ::=  SEQUENCE  {
    //         extnID      OBJECT IDENTIFIER,
    //         critical    BOOLEAN DEFAULT FALSE,
    //         extnValue   OCTET STRING
    //                     -- contains the DER encoding of an ASN.1 value
    //                     -- corresponding to the extension type identified
    //                     -- by extnID
    //         }
    // ```
    //
    // [RFC 5280 Section 4.1.2.9]: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.9
    #[derive(Clone, Debug, Eq, PartialEq, Sequence)]
    pub struct ExtensionExample<'a> {
        /// extnID      OBJECT IDENTIFIER,
        pub extn_id: ObjectIdentifier,

        /// critical    BOOLEAN DEFAULT FALSE,
        #[asn1(default = "default_false_example")]
        pub critical: bool,

        /// extnValue   OCTET STRING
        #[asn1(type = "OCTET STRING")]
        pub extn_value: &'a [u8],
    }

    /// X.509 `AlgorithmIdentifier`
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Sequence, ValueOrd)]
    pub struct AlgorithmIdentifier<'a> {
        pub algorithm: ObjectIdentifier,
        pub parameters: Option<AnyRef<'a>>,
    }

    /// X.509 `SubjectPublicKeyInfo` (SPKI)
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Sequence, ValueOrd)]
    pub struct SubjectPublicKeyInfo<'a> {
        pub algorithm: AlgorithmIdentifier<'a>,
        #[asn1(type = "BIT STRING")]
        pub subject_public_key: &'a [u8],
    }

    /// PKCS#8v2 `OneAsymmetricKey`
    #[derive(Sequence)]
    pub struct OneAsymmetricKey<'a> {
        pub version: u8,
        pub private_key_algorithm: AlgorithmIdentifier<'a>,
        #[asn1(type = "OCTET STRING")]
        pub private_key: &'a [u8],
        #[asn1(context_specific = "0", extensible = "true", optional = "true")]
        pub attributes: Option<SetOf<AnyRef<'a>, 1>>,
        #[asn1(
            context_specific = "1",
            extensible = "true",
            optional = "true",
            type = "BIT STRING"
        )]
        pub public_key: Option<&'a [u8]>,
    }

    /// X.509 extension
    // TODO(tarcieri): tests for code derived with the `default` attribute
    #[derive(Clone, Debug, Eq, PartialEq, Sequence, ValueOrd)]
    pub struct Extension<'a> {
        extn_id: ObjectIdentifier,
        #[asn1(default = "critical_default")]
        critical: bool,
        #[asn1(type = "OCTET STRING")]
        extn_value: &'a [u8],
    }

    /// Default value of the `critical` bit
    fn critical_default() -> bool {
        false
    }

    const ID_EC_PUBLIC_KEY_OID: ObjectIdentifier =
        ObjectIdentifier::new_unwrap("1.2.840.10045.2.1");

    const PRIME256V1_OID: ObjectIdentifier = ObjectIdentifier::new_unwrap("1.2.840.10045.3.1.7");

    const ALGORITHM_IDENTIFIER_DER: &[u8] =
        &hex!("30 13 06 07 2a 86 48 ce 3d 02 01 06 08 2a 86 48 ce 3d 03 01 07");

    #[derive(Sequence)]
    #[asn1(tag_mode = "IMPLICIT")]
    pub struct TypeCheckExpandedSequenceFieldAttributeCombinations<'a> {
        pub simple: bool,
        #[asn1(type = "BIT STRING")]
        pub typed: &'a [u8],
        #[asn1(context_specific = "0")]
        pub context_specific: bool,
        #[asn1(optional = "true")]
        pub optional: Option<bool>,
        #[asn1(default = "default_false_example")]
        pub default: bool,
        #[asn1(type = "BIT STRING", context_specific = "1")]
        pub typed_context_specific: &'a [u8],
        #[asn1(context_specific = "2", optional = "true")]
        pub context_specific_optional: Option<bool>,
        #[asn1(context_specific = "3", default = "default_false_example")]
        pub context_specific_default: bool,
        #[asn1(type = "BIT STRING", context_specific = "4", optional = "true")]
        pub typed_context_specific_optional: Option<&'a [u8]>,
    }

    #[derive(Sequence)]
    #[asn1(error = CustomError)]
    pub struct TypeWithCustomError {
        pub simple: bool,
    }

    #[test]
    fn idp_test() {
        let idp = IssuingDistributionPointExample::from_der(&hex!("30038101FF")).unwrap();
        assert_eq!(idp.only_contains_user_certs, true);
        assert_eq!(idp.only_contains_cacerts, false);
        assert_eq!(idp.indirect_crl, false);
        assert_eq!(idp.only_contains_attribute_certs, false);

        let idp = IssuingDistributionPointExample::from_der(&hex!("30038201FF")).unwrap();
        assert_eq!(idp.only_contains_user_certs, false);
        assert_eq!(idp.only_contains_cacerts, true);
        assert_eq!(idp.indirect_crl, false);
        assert_eq!(idp.only_contains_attribute_certs, false);

        let idp = IssuingDistributionPointExample::from_der(&hex!("30038401FF")).unwrap();
        assert_eq!(idp.only_contains_user_certs, false);
        assert_eq!(idp.only_contains_cacerts, false);
        assert_eq!(idp.indirect_crl, true);
        assert_eq!(idp.only_contains_attribute_certs, false);

        let idp = IssuingDistributionPointExample::from_der(&hex!("30038501FF")).unwrap();
        assert_eq!(idp.only_contains_user_certs, false);
        assert_eq!(idp.only_contains_cacerts, false);
        assert_eq!(idp.indirect_crl, false);
        assert_eq!(idp.only_contains_attribute_certs, true);
    }

    // demonstrates default field that is not context specific
    #[test]
    fn extension_test() {
        let ext1 = ExtensionExample::from_der(&hex!(
            "300F"        //  0  15: SEQUENCE {
            "0603551D13"  //  2   3:   OBJECT IDENTIFIER basicConstraints (2 5 29 19)
            "0101FF"      //  7   1:   BOOLEAN TRUE
            "0405"        //  10   5:   OCTET STRING, encapsulates {
            "3003"        //  12   3:     SEQUENCE {
            "0101FF"      //  14   1:       BOOLEAN TRUE
        ))
        .unwrap();
        assert_eq!(ext1.critical, true);

        let ext2 = ExtensionExample::from_der(&hex!(
            "301F"                                            //  0  31: SEQUENCE {
            "0603551D23"                                      //  2   3:   OBJECT IDENTIFIER authorityKeyIdentifier (2 5 29 35)
            "0418"                                            //  7  24:   OCTET STRING, encapsulates {
            "3016"                                            //  9  22:     SEQUENCE {
            "8014E47D5FD15C9586082C05AEBE75B665A7D95DA866"    // 11  20:       [0] E4 7D 5F D1 5C 95 86 08 2C 05 AE BE 75 B6 65 A7 D9 5D A8 66
        ))
        .unwrap();
        assert_eq!(ext2.critical, false);
    }

    #[test]
    fn decode() {
        let algorithm_identifier = AlgorithmIdentifier::from_der(ALGORITHM_IDENTIFIER_DER).unwrap();

        assert_eq!(ID_EC_PUBLIC_KEY_OID, algorithm_identifier.algorithm);
        assert_eq!(
            PRIME256V1_OID,
            ObjectIdentifier::try_from(algorithm_identifier.parameters.unwrap()).unwrap()
        );

        let t = TypeWithCustomError::from_der(&hex!("30030101FF")).unwrap();
        assert!(t.simple);
    }

    #[test]
    fn encode() {
        let parameters_oid = PRIME256V1_OID;

        let algorithm_identifier = AlgorithmIdentifier {
            algorithm: ID_EC_PUBLIC_KEY_OID,
            parameters: Some(AnyRef::from(&parameters_oid)),
        };

        assert_eq!(
            ALGORITHM_IDENTIFIER_DER,
            algorithm_identifier.to_der().unwrap()
        );
    }
}

#[cfg(all(feature = "derive", feature = "oid"))]
mod sequence_application {
    use const_oid::ObjectIdentifier;
    use der::{asn1::ApplicationImplicit, Decode, Encode, Sequence};
    use hex_literal::hex;

    const TACHO_CERT_DER: &[u8] = &hex!(
    "7F 21  81 C8" // Application 33

        "7F 4E  81 81" // Appliction 78

            "5F 29" // Application 41
                "01 00"
            "42 08" // Application 2
                "FD 45 43 20 01 FF FF 01"
            "5F 4C  07" // Application 76
                "FF 53 4D 52 44 54 0E"
            "7F 49  4D" // Application 73
                "06 08 2A 86 48  CE 3D 03 01 07 86 41 04
        30 E8 EE D8 05 1D FB 8F  05 BF 4E 34 90 B8 A0 1C
        83 21 37 4E 99 41 67 70  64 28 23 A2 C9 E1 21 16
        D9 27 46 45 94 DD CB CC  79 42 B5 F3 EE 1A A3 AB
        A2 5C E1 6B 20 92 00 F0  09 70 D9 CF 83 0A 33 4B"


            "5F 20 08" // Application 32
                "17 47 52 20 02  FF FF 01"
            "5F 25 04" // Application 37
                "62 A3 B0 D0"
            "5F 24 04" // Application 36
                "6F F6 49 50"
        "5F 37 40" // Application 55
            "6D 3E FD 97
        BE 83 EC 65 5F 51 4D 8C  47 60 DB FD 9B A2 D1 5D
        3C 1A 21 93 CE D7 EA F2  A2 0D 89 CC 4A 4F 0C 4B
        E5 3F A3 F9 0F 20 B5 74  67 26 DB 19 9E FF DE 0B
        D0 B9 2C B9 D1 5A E2 18  08 6C F0 E2"
    );

    /// EU Tachograph certificate
    pub type TachographCertificate<'a> = ApplicationImplicit<33, TachographCertificateInner<'a>>;

    /// EU Tachograph certificate inner sequence
    #[derive(Sequence)]
    #[asn1(tag_mode = "IMPLICIT")]
    pub struct TachographCertificateInner<'a> {
        /// constructed
        #[asn1(application = "78")]
        pub body: TachographCertificateBody<'a>,

        /// primitive
        #[asn1(application = "55", type = "OCTET STRING")]
        pub signature: &'a [u8],
    }

    /// EU Tachograph certificate body
    #[derive(Sequence)]
    #[asn1(tag_mode = "IMPLICIT")]

    pub struct TachographCertificateBody<'a> {
        /// primitive
        #[asn1(application = "41", type = "OCTET STRING")]
        pub profile_identifier: &'a [u8],

        /// primitive
        #[asn1(application = "2", type = "OCTET STRING")]
        pub authority_reference: &'a [u8],

        /// primitive
        #[asn1(application = "76", type = "OCTET STRING")]
        pub holder_authorisation: &'a [u8],

        /// constructed
        #[asn1(application = "73")]
        pub public_key: CertificatePublicKey<'a>,

        /// primitive
        #[asn1(application = "32", type = "OCTET STRING")]
        pub holder_reference: &'a [u8],

        /// primitive
        #[asn1(application = "37", type = "OCTET STRING")]
        pub effective_date: &'a [u8],

        /// primitive
        #[asn1(application = "36", type = "OCTET STRING")]
        pub expiration_date: &'a [u8],
    }

    /// EU Tachograph certificate public key
    #[derive(Sequence)]
    #[asn1(tag_mode = "IMPLICIT")]

    pub struct CertificatePublicKey<'a> {
        pub domain_parameters: ObjectIdentifier,

        #[asn1(context_specific = "6", type = "OCTET STRING")]
        pub public_point: &'a [u8],
    }
    #[test]
    fn decode_tacho_application_tags() {
        let tacho_cert = TachographCertificate::from_der(TACHO_CERT_DER).unwrap();

        let sig = tacho_cert.value.signature;
        assert_eq!(&sig[..2], hex!("6D 3E"));
        assert_eq!(tacho_cert.value.body.profile_identifier, &[0x00]);
        assert_eq!(
            tacho_cert.value.body.authority_reference,
            hex!("FD 45 43 20 01 FF FF 01")
        );
        assert_eq!(
            tacho_cert.value.body.holder_authorisation,
            hex!("FF 53 4D 52 44 54 0E")
        );
        assert_eq!(
            tacho_cert.value.body.public_key.domain_parameters,
            ObjectIdentifier::new_unwrap("1.2.840.10045.3.1.7")
        );
        assert_eq!(
            &tacho_cert.value.body.public_key.public_point[..4],
            hex!("04 30 E8 EE")
        );
        const GREECE: &[u8] = b"GR ";
        assert_eq!(&tacho_cert.value.body.holder_reference[1..4], GREECE);

        // Re-encode
        let mut buf = [0u8; 256];
        let encoded = tacho_cert.encode_to_slice(&mut buf).unwrap();
        assert_eq!(encoded, TACHO_CERT_DER);
    }
}

mod infer_default {
    //! When another crate might define a PartialEq for another type, the use of
    //! `default="Default::default"` in the der derivation will not provide enough
    //! information for `der_derive` crate to figure out.
    //!
    //! This provides a reproduction for that case. This is intended to fail when we
    //! compile tests.
    //! ```
    //! error[E0282]: type annotations needed
    //!   --> der/tests/derive.rs:480:26
    //!    |
    //!480 |         #[asn1(default = "Default::default")]
    //!    |                          ^^^^^^^^^^^^^^^^^^ cannot infer type
    //!
    //!error[E0283]: type annotations needed
    //!   --> der/tests/derive.rs:478:14
    //!    |
    //!478 |     #[derive(Sequence)]
    //!    |              ^^^^^^^^ cannot infer type
    //!    |
    //!note: multiple `impl`s satisfying `bool: PartialEq<_>` found
    //!   --> der/tests/derive.rs:472:5
    //!    |
    //!472 |     impl PartialEq<BooleanIsh> for bool {
    //!    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //!    = note: and another `impl` found in the `core` crate:
    //!            - impl<host> PartialEq for bool
    //!              where the constant `host` has type `bool`;
    //!    = note: required for `&bool` to implement `PartialEq<&_>`
    //!    = note: this error originates in the derive macro `Sequence` (in Nightly builds, run with -Z macro-backtrace for more info)
    //! ```

    use der::Sequence;

    struct BooleanIsh;

    impl PartialEq<BooleanIsh> for bool {
        fn eq(&self, _other: &BooleanIsh) -> bool {
            unimplemented!("This is only here to mess up the compiler's type inference")
        }
    }

    #[derive(Sequence)]
    struct Foo {
        #[asn1(default = "Default::default")]
        pub use_default_default: bool,

        #[asn1(default = "something_true")]
        pub use_custom: bool,
    }

    fn something_true() -> bool {
        todo!()
    }
}
